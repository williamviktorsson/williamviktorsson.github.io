import{i as E,f as l,t as d,j as c,k as e,g as n}from"../chunks/disclose-version.BmIQt7z6.js";import{s as t,B as C,z as M,f as je}from"../chunks/runtime.Bix74eL6.js";import{e as s}from"../chunks/render.DlfULs-I.js";import{b as O}from"../chunks/this.wyHJEu0o.js";import{C as H}from"../chunks/code.seIn7Zd2.js";import{P as xe,S as w,T as S,C as P}from"../chunks/content.DTFQcm-x.js";import{F as Ae}from"../chunks/front.DnDuSa6w.js";import{S as U}from"../chunks/split.B0OcPuxR.js";var Fe=d('<ol><li class="fragment">Kort repetition</li> <li class="fragment">Kursen närmsta veckorna</li> <li class="fragment">Asynkron programmering</li> <li class="fragment">OOP</li> <li class="fragment">Serverprogrammering?</li> <li class="fragment">Inspelning - inlämning - OBS</li> <li class="fragment">Git</li></ol>'),Le=d("<!> <!>",5),Te=d('<ol><li class="fragment">Denna vecka</li> <ul><li class="fragment">Bli klar med första examinerande uppgiften</li> <li class="fragment">Fokus på klasser, funktioner, iterering - grundläggande syntax i Dart</li></ul> <li class="fragment">Nästa vecka (& nästa uppgift)</li> <ul><li class="fragment">Påbörja simpel serverprogrammering</li> <li class="fragment">Fokus på asynkrona anrop & hämta data över nätverk</li> <li class="fragment">Lite översiktligt om routing, json & http-requests</li> <li class="fragment"><strong>Nya Repository-implementationer som utför sina operationer mot denna nya server</strong></li></ul> <li class="fragment">Veckan efter</li> <ul><li class="fragment">Utöka server till att erbjuda persistent datalagring</li></ul></ol>'),De=d("<!> <!>",5),Re=d(`<ul><li class="fragment">Varför behövs asynkron programmering?</li> <ol><li class="fragment">Förhindrar blockering av användaregränssnitt</li> <ul><li class="fragment">Tillåter processorn att fortsätta med andra uppdrag medans asynkrona uppdrag
								bearbetas i bakgrunden</li></ul> <li class="fragment">Hantera nätverksförfrågningar (HTTP)</li> <li class="fragment">Utföra databasoperationer</li></ol> <li class="fragment">Grundläggande koncept</li> <ol><li class="fragment">Future, async och await</li> <li class="fragment">Streams för kontinuerliga uppdateringar</li></ol> <li class="fragment">Felhantering</li> <ol><li class="fragment">Try-catch med async-await</li></ol></ul> <div><div class="enter"><!></div></div>`,1),Ie=d("<!> <!>",5),Ne=d('<ul><li class="fragment">Klasser och Objekt</li> <ol><li class="fragment">Klasser definerar datastruktur och beteende</li> <li class="fragment">Arv möjliggör kodåteranvändning</li></ol> <li class="fragment">Inkapsling och Access Modifiers</li> <ol><li class="fragment">Privata variabler och publika metoder</li></ol> <li class="fragment">Generics & Abstrakta klasser</li> <ol><li class="fragment">Generics för flexibel och typesäker kod</li> <li class="fragment">Abstrakt klass för att definiera gemensamma beteenden eller påtvinga implementationer</li> <ul><li class="fragment">utan att tillåta instansiering</li></ul></ol></ul> <div><div class="enter"><!></div></div>',1),qe=d("<!> <!>",5),Ge=d('<ul><li class="fragment">Polymorfism</li> <ol><li class="fragment">Subklasser kan användas som om de vore av föräldraklassens typ</li> <li class="fragment">Samma kod kan leda till olika beteenden beroende på subklassers implementation</li></ol></ul> <div><div class="enter"><!></div></div>',1),Ve=d("<!> <!>",5),Ke=d('<ul><li class="fragment">Vad är klient-server-modellen?</li> <ul><li class="fragment">Klient: Enheten som begär data eller tjänster (t.ex. webbläsare, mobilapp)</li> <li class="fragment">Server: Dator som tillhandahåller data eller tjänster till klienter</li> <ul><li class="fragment">Svarar på requests från klienter</li> <li class="fragment">Lagrar och hanterar data</li></ul></ul> <li class="fragment">Serveruppgifter i parkeringsappen</li> <ul><li class="fragment">Hantera databasoperationer (spara/hämta parkeringar)</li> <li class="fragment">Bearbeta klientförfrågningar (t.ex. hitta ledig plats)</li> <li class="fragment">Upprätthålla applikationslogik (t.ex. beräkna parkeringsavgift)</li></ul> <li class="fragment">Grundläggande serverstruktur</li> <ol><li class="fragment">Exempel på serverstruktur (pseudo-kod)</li></ol> <li class="fragment">Nyckelkoncept</li> <ul><li class="fragment">Routing: Dirigera förfrågningar till rätt handler (funktion?)</li> <li class="fragment">Request/Response: Struktur för klient-server-kommunikation</li> <li class="fragment">JSON: Vanligt format för datautbyte</li> <li class="fragment">Asynkron programmering</li></ul></ul> <div><div class="enter"><!></div></div>',1),Ee=d("<!> <!>",5),Je=d(`<ol><li class="fragment">Förberedelser</li> <ul><li class="fragment">Ladda ner och installera OBS Studio från <a href="https://obsproject.com/" class="svelte-1322xwn">officiella hemsidan</a></li> <li class="fragment">Starta OBS Studio och kör eventuell automatisk konfiguration</li></ul> <li class="fragment">Konfigurera scenen</li> <ul><li class="fragment">Klicka på '+' under 'Sources' och välj lämpliga källor (t.ex. 'Display Capture' eller
						'Window Capture')</li> <li class="fragment">Justera källornas storlek och position i förhandsgranskningsfönstret (högerklicka +
						'Resize output')</li></ul> <li class="fragment">Ljudinställningar</li> <ul><li class="fragment">Kontrollera att rätt mikrofon är vald under 'Settings/Audio/Monitoring Device'</li> <li class="fragment">Justera ljudnivåer för mikrofon och datorljud i 'Audio Mixer'</li></ul> <li class="fragment">Inspelningsinställningar</li> <ul><li class="fragment">Gå till Settings/Output och välj 'Recording Path' och 'Recording Format'</li> <li class="fragment">Mappen väljer du själv, för format föreslår jag Fragmented MP4</li></ul> <li class="fragment">Starta inspelningen</li> <ul><li class="fragment">Klicka på 'Start Recording' i huvudmenyn</li> <li class="fragment">Utför din presentation eller demonstration</li> <li class="fragment">Klicka på 'Stop Recording' när du är klar</li></ul> <li class="fragment">Efter inspelningen</li> <ul><li class="fragment">Hitta den inspelade filen i den konfigurerade inspelningsmappen</li></ul></ol>`),Be=d("<!> <!>",5),Ce=d('<ol><li class="fragment">Ladda ned Git från <a href="https://git-scm.com/" class="svelte-1322xwn">https://git-scm.com/</a></li> <li class="fragment">Skapa ett GitHub konto på <a href="https://github.com/" class="svelte-1322xwn">GitHub</a></li> <ul><li class="fragment">Existerande konto eller t.ex. GitLab konto går också bra</li></ul> <li class="fragment">Öppna en terminal.</li> <ul><li class="fragment">För Windows-uppskattare: WSL eller Git Bash.</li></ul> <li class="fragment">Generera en SSH-nyckel på din dator (<a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" class="svelte-1322xwn">guide</a>)</li> <ul><li style="list-style: none;" class="fragment"><code class="svelte-1322xwn">ssh-keygen -t ed25519 -C "your_email@example.com"</code></li> <ul><li class="fragment">ENTER, ENTER, ENTER (acceptera defaults)</li></ul></ul> <li class="fragment">Skriv ut din publika nyckel så du kan lägga till på GitHub</li> <ul><li style="list-style: none;" class="fragment"><code class="svelte-1322xwn">cat ~/.ssh/id_ed25519.pub</code></li> <ul><li class="fragment">kopiera (ctrl+c)</li></ul></ul> <li class="fragment">Lägg till nyckeln på GitHub under <a href="https://github.com/settings/keys" class="svelte-1322xwn">https://github.com/settings/keys</a></li></ol>'),Me=d("<!> <!>",5),Oe=d('<ol><li class="fragment">Skapa ett <a href="https://github.com/" class="svelte-1322xwn">Nytt projekt på GitHub</a></li> <li class="fragment">Under Quick setup: Välj <code class="svelte-1322xwn">SSH</code></li> <li class="fragment">Kopiera koden från <code class="svelte-1322xwn">...or push an existing repository from the command line</code></li> <li class="fragment">Öppna en terminal i ditt projekt.</li> <ul><li class="fragment">Förslag 1: Navigera till projektet med <code class="svelte-1322xwn">cd</code></li> <li class="fragment">Förslag 2: Öppna i VSCode</li></ul> <li class="fragment">Initiera ditt git-projekt och lägg till alla filer</li> <ul><li style="list-style: none;" class="fragment"><code class="svelte-1322xwn">git init</code></li> <li style="list-style: none;" class="fragment"><code class="svelte-1322xwn">git add .</code></li> <li style="list-style: none;" class="fragment"><code class="svelte-1322xwn">git commit -m "first commit"</code></li></ul> <li class="fragment">Klistra in koden du kopierat:</li> <ul><li style="list-style: none;" class="fragment"><code class="svelte-1322xwn">git remote add origin git@github.com:williamviktorsson/example.git</code></li> <li style="list-style: none;" class="fragment"><code class="svelte-1322xwn">git branch -M main</code></li> <li style="list-style: none;" class="fragment"><code class="svelte-1322xwn">git push -u origin main</code></li></ul> <li class="fragment">Nu är du redo att börja koda och versionshantera dina ändringar!</li></ol>'),He=d("<!> <!>",5),Ue=d('<ol><li class="fragment">Gör ändringar i dina filer</li> <li class="fragment">Förbered din nästa "commit" med att lägga till ändringarna:</li> <ul><li class="fragment"><code class="svelte-1322xwn">git add &lt;filnamn&gt;</code> för att lägga till en specifik fil, eller:</li> <li class="fragment"><code class="svelte-1322xwn">git add .</code> (för alla ändringar)</li></ul> <li class="fragment">Commita ändringar: <code class="svelte-1322xwn">git commit -m "Ditt commit-meddelande"</code></li> <li class="fragment">Pusha ändringar till remote (GitHub/GitLab): <code class="svelte-1322xwn">git push</code></li> <li class="fragment">Innan du börjar nytt arbete, hämta senaste ändringarna från remote: <code class="svelte-1322xwn">git pull</code></li> <li class="fragment">Kontrollera status när som helst: <code class="svelte-1322xwn">git status</code></li> <li class="fragment">Grundläggande branching:</li> <ol style="list-style: lower-latin;"><li class="fragment">Skapa ny branch: <code class="svelte-1322xwn">git branch &lt;namn&gt;</code></li> <li class="fragment">Byt till ny branch: <code class="svelte-1322xwn">git checkout &lt;namn&gt;</code></li> <li class="fragment">Sammanfoga (merge) branch till main:</li> <ul style="list-style"><li class="fragment"><code class="svelte-1322xwn">git checkout main</code></li> <li class="fragment"><code class="svelte-1322xwn">git merge &lt;namn&gt;</code></li></ul></ol></ol>'),We=d("<!> <!>",5),ze=d(`<div class="mt-60 text-center">Det var allt för idag! Nästa vecka börjar det bli mer nytt innehåll och mer komplexa
				koncept!</div>`),Qe=d("<!> <!>",5),Xe=d('<ul><li class="fragment">Vad är ett Repository?</li> <ul><li class="fragment">En abstraktion för datalagring som döljer implementationsdetaljer</li> <li class="fragment">Ger ett enhetligt gränssnitt för att hantera data oavsett lagringssätt</li></ul> <li class="fragment">Lokal Fillagring</li> <ul><li class="fragment">Basstruktur för filbaserat repository</li> <li class="fragment">Läsning från fil med felhantering</li> <li class="fragment">Skrivning till fil och operationer</li></ul> <li class="fragment">Praktiskt Exempel</li></ul> <div><div class="enter"><!></div></div>',1),Ye=d("<!> <!>",5),Ze=d('<!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <!> <div class="date svelte-1322xwn"><p class="mb-2 text-xl" id="date"> </p> <p class="text-xl">Stockholms Tekniska Institut</p></div>',5);function ca(me){const fe={year:"numeric",month:"long",day:"numeric"},ve=new Date().toLocaleDateString("sv-SE",fe);let y,F,J,$,R,a=je(!1);var Y=E(!0),ke=c(Y);xe(ke,{options:{history:!0,transition:"slide",controls:!0,progress:!1,autoAnimateEasing:"ease",autoAnimateUnmatched:!0},children:(he,aa)=>{var Z=Ze(),ee=c(Z);Ae(ee,{});var ae=e(e(ee,!0));w(ae,{children:(u,j)=>{var r=Le(),i=c(r);S(i,{title:"Föreläsning 2 - blandat nyttigt för lyckat kursgenomförande"});var g=e(e(i,!0));P(g,{children:(p,x)=>{var o=Fe();l(p,o)},$$slots:{default:!0}}),l(u,r)},$$slots:{default:!0}});var te=e(e(ae,!0));w(te,{children:(u,j)=>{var r=De(),i=c(r);S(i,{title:"Kursen närmsta veckorna"});var g=e(e(i,!0));P(g,{children:(p,x)=>{var o=Te();l(p,o)},$$slots:{default:!0}}),l(u,r)},$$slots:{default:!0}});var re=e(e(te,!0));w(re,{children:(u,j)=>{var r=Ie(),i=c(r);S(i,{title:"Asynkron Programmering i Dart"});var g=e(e(i,!0));P(g,{children:(p,x)=>{var o=E(!0),I=c(o);U(I,{children:(N,W)=>{var m=Re(),f=c(m),v=n(f),k=e(e(v,!0)),_=n(k),L=e(e(_,!0)),h=e(e(L,!0)),b=e(e(h,!0)),A=e(e(k,!0)),T=e(e(A,!0)),q=n(T),G=e(e(q,!0)),D=e(e(T,!0)),V=e(e(D,!0)),K=n(V),B=e(e(f,!0)),z=n(B),Q=n(z);O(H(Q,{code:"",theme:"catppuccin-frappe",lang:"dart",autoIndent:!0,options:{duration:600,stagger:15,containerStyle:!1,lineNumbers:!0},class:"overflow-y-clip"}),X=>$=X,()=>$),C(()=>z.hidden=!M(a)),s("current",v,async()=>{t(a,!1),await $.update``},!1),s("current",_,async()=>{t(a,!0),await $.update`// Synkron kod (kan blockera UI)
void fetchParkingData() {
	var data = readLargeDataFile(); // Tar lång tid
	processData(data);
	updateUI();
}

// Asynkron kod (non-blocking)
Future<void> fetchParkingDataAsync() async {
	var data = await readLargeDataFileAsync(); // await tillåter processorn att fortsätta med andra uppdrag medans data hämtas
	processData(data);
	updateUI();
}`},!1),s("current",h,async()=>{t(a,!0),await $.update`// HTTP-förfrågan för att hämta parkeringsplatser
Future<List<ParkingSpot>> fetchParkingSpots() async {
	final response = await http.get('https://api.parkering.se/spots');
	if (response.statusCode == 200) {
		// Parsera JSON och returnera lista av parkeringsplatser
		return parseSpots(response.body);
	} else {
		throw Exception('Kunde inte hämta parkeringsplatser');
	}
}

	// Användning
void updateParkingSpots() async {
	try {
		List<ParkingSpot> spots = await fetchParkingSpots();
		updateUI(spots);
	} catch (e) {
		showError('Fel vid hämtning av parkeringsplatser');
	}
}`},!1),s("current",b,async()=>{t(a,!0),await $.update`// Databasoperation för att spara en parkering
Future<void> saveParkingToDB(Parking parking) async {
	final db = await openDatabase('parking.db');
	await db.insert('parkings', parking.toMap());
	await db.close();
}

// Användning
void startParking(Vehicle vehicle, ParkingSpot spot) async {
	final parking = Parking(
		vehicle: vehicle,
		spot: spot,
		startTime: DateTime.now()
	);
	try {
		await saveParkingToDB(parking);
		showMessage('Parkering påbörjad');
	} catch (e) {
		showError('Kunde inte spara parkeringen');
	}
}`},!1),s("current",A,async()=>{t(a,!1),await $.update``},!1),s("current",q,async()=>{t(a,!0),await $.update`Future<ParkingSpot> findAvailableSpot() async {
	// Simulerar en tidskrävande operation
	await Future.delayed(Duration(seconds: 2));
	return ParkingSpot(id: '1', isAvailable: true);
}

// Användning med await
void parkCar() async {
	print('Letar efter ledig plats...');
	ParkingSpot spot = await findAvailableSpot();
	print('Plats hittad: ' + spot.id);
}

// Användning med .then()
void parkCarThen() {
	print('Letar efter ledig plats...');
	findAvailableSpot().then((spot) {
		print('Plats hittad: ' + spot.id);
	});
}`},!1),s("current",G,async()=>{t(a,!0),await $.update`Future<List<Vehicle>> fetchParkedVehicles() async {
	// Simulerar hämtning från databas
	await Future.delayed(Duration(seconds: 1));
	return [
		Vehicle(registrationNumber: 'ABC123', type: 'Car'),
		Vehicle(registrationNumber: 'XYZ789', type: 'Motorcycle')
	];
}

Stream<Vehicle> streamParkedVehicles() async* {
	List<Vehicle> vehicles = await fetchParkedVehicles();
	for (var vehicle in vehicles) {
		await Future.delayed(Duration(seconds: 1)); // Simulerar realtidsuppdateringar
		yield vehicle;
	}
}

// Användning
void monitorParking() {
	streamParkedVehicles().listen((vehicle) {
		print('Parkerat fordon: ' + vehicle.registrationNumber);
	});
}`},!1),s("current",D,async()=>{t(a,!1),await $.update``},!1),s("current",K,async()=>{t(a,!0),await $.update`Future<void> endParking(String registrationNumber) async {
	try {
		final parking = await findActiveParking(registrationNumber);
		parking.endTime = DateTime.now();
		await updateParkingInDB(parking);
		print('Parkering avslutad för ' + registrationNumber);
	} catch (e) {
		print('Fel vid avslutning av parkering: $e');
	}
}

Future<Parking> findActiveParking(String registrationNumber) async {
	// Simulerar databassökning
	await Future.delayed(Duration(seconds: 1));
	throw Exception('Ingen aktiv parkering hittad');
}

Future<void> updateParkingInDB(Parking parking) async {
	// Simulerar databasuppdatering
	await Future.delayed(Duration(seconds: 1));
	print('Parkering uppdaterad i databasen');
}`},!1),l(N,m)},$$slots:{default:!0}}),l(p,o)},$$slots:{default:!0}}),l(u,r)},$$slots:{default:!0}});var ie=e(e(re,!0));w(ie,{in:async()=>{t(a,!1),await F.update``},children:(u,j)=>{var r=qe(),i=c(r);S(i,{title:"Objektorienterad Programmering i Dart"});var g=e(e(i,!0));P(g,{children:(p,x)=>{var o=E(!0),I=c(o);U(I,{children:(N,W)=>{var m=Ne(),f=c(m),v=n(f),k=e(e(v,!0)),_=n(k),L=e(e(_,!0)),h=e(e(k,!0)),b=e(e(h,!0)),A=n(b),T=e(e(b,!0)),q=e(e(T,!0)),G=n(q),D=e(e(f,!0)),V=n(D),K=n(V);O(H(K,{code:"",theme:"catppuccin-frappe",lang:"dart",autoIndent:!0,options:{duration:600,stagger:15,containerStyle:!1,lineNumbers:!0},class:"overflow-y-clip"}),B=>F=B,()=>F),C(()=>V.hidden=!M(a)),s("current",v,async()=>{t(a,!1),await F.update``},!1),s("current",_,async()=>{t(a,!0),await F.update`class Person {
	String name;
	Person({required this.name});
}

// Skapa ett objekt
Person alice = Person(name: "Alice");`},!1),s("current",L,async()=>{t(a,!0),await F.update`class Person {
	String name;
	Person({required this.name});
}

// Skapa ett objekt
Person alice = Person(name: "Alice");

// Arv
class Vehicle {
	String regnr;
	Vehicle(required this.regnr);
}

// Komposition
class Car extends Vehicle {
	Person owner;
	Car({required String regnr, required this.owner}) : super(regnr: regnr);
}`},!1),s("current",h,async()=>{t(a,!1),await F.update``},!1),s("current",A,async()=>{t(a,!0),await F.update`class BankAccount {
	String _accountNumber; // Privat variabel
	double _balance = 0;

	BankAccount(this._accountNumber);

	void deposit(double amount) {
		_balance += amount;
	}

	double get balance => _balance; // Publik getter
}`},!1),s("current",T,async()=>{t(a,!1),await F.update``},!1),s("current",G,async()=>{t(a,!0),await F.update`// Abstrakt klass kan ha metodimplementationer men kan inte instansieras.
// Endast konkreta klasser som ärver från Repository kan skapas.
abstract class Repository<T> {
	List<T> _items = [];

	void add(T item) => _items.add(item);

	List<T> getAll() => _items;

	void update(T item, T newItem) {
		var index = _items.indexWhere((element) => element == item);
		_items[index] = newItem;
	}

	void delete(T item) => _items.remove(item);
}

// lagrar och tar endast emot Person-objekt
class PersonRepository extends Repository<Person> {}

// lagrar och tar endast emot Vehicle-objekt
class VehicleRepository extends Repository<Vehicle> {}

// Notera implementationen återanvänds. Ingen repeterad kod :-)
`},!1),l(N,m)},$$slots:{default:!0}}),l(p,o)},$$slots:{default:!0}}),l(u,r)},$$slots:{default:!0}});var se=e(e(ie,!0));w(se,{in:async()=>{t(a,!1),await J.update``},children:(u,j)=>{var r=Ve(),i=c(r);S(i,{title:"OOP i Dart - fortsättning"});var g=e(e(i,!0));P(g,{children:(p,x)=>{var o=E(!0),I=c(o);U(I,{children:(N,W)=>{var m=Ge(),f=c(m),v=n(f),k=e(e(v,!0)),_=n(k),L=e(e(f,!0)),h=n(L),b=n(h);O(H(b,{code:"",theme:"catppuccin-frappe",lang:"dart",autoIndent:!0,options:{duration:600,stagger:15,containerStyle:!1,lineNumbers:!0},class:"overflow-y-clip"}),A=>J=A,()=>J),C(()=>h.hidden=!M(a)),s("current",v,async()=>{t(a,!1),await J.update``},!1),s("current",_,async()=>{t(a,!0),await J.update`void printArea(Shape shape) {
	print("Area: " + shape.getArea());
}

// Användning
printArea(Circle(5));
printArea(Square(4));`},!1),l(N,m)},$$slots:{default:!0}}),l(p,o)},$$slots:{default:!0}}),l(u,r)},$$slots:{default:!0}});var le=e(e(se,!0));w(le,{in:async()=>{t(a,!1),await y.update``},children:(u,j)=>{var r=Ee(),i=c(r);S(i,{title:"Introduktion till Serverprogrammering"});var g=e(e(i,!0));P(g,{children:(p,x)=>{var o=E(!0),I=c(o);U(I,{children:(N,W)=>{var m=Ke(),f=c(m),v=n(f),k=e(e(v,!0)),_=n(k),L=e(e(_,!0)),h=e(e(L,!0)),b=n(h),A=e(e(b,!0)),T=e(e(k,!0)),q=e(e(T,!0)),G=e(e(q,!0)),D=e(e(G,!0)),V=n(D),K=e(e(D,!0)),B=e(e(K,!0)),z=n(B),Q=e(e(z,!0)),X=e(e(Q,!0)),we=e(e(X,!0)),Se=e(e(f,!0)),pe=n(Se),Pe=n(pe);O(H(Pe,{code:"",theme:"catppuccin-frappe",lang:"dart",autoIndent:!0,options:{duration:600,stagger:15,containerStyle:!1,lineNumbers:!0},class:"overflow-y-clip"}),$e=>y=$e,()=>y),C(()=>pe.hidden=!M(a)),s("current",v,async()=>{t(a,!1),await y.update``},!1),s("current",_,async()=>{t(a,!0),await y.update`// Klient (mobilapp)
Future<void> getAndDisplayAvailableSpots() async {

	final response = await http.get('https://parkering-api.se/spots/available');
	final List<dynamic> data = json.decode(response.body);
	final spots = data.map((json) => ParkingSpot.fromJson(json)).toList();
	displaySpots(spots);

}

`},!1),s("current",b,async()=>{t(a,!0),await y.update`// Klient (mobilapp)
Future<void> getAndDisplayAvailableSpots() async {

	final response = await http.get('https://parkering-api.se/spots/available');
	final List<dynamic> data = json.decode(response.body);
	final spots = data.map((json) => ParkingSpot.fromJson(json)).toList();
	displaySpots(spots);

}

// Server
app.get('/spots/available', (req, res) async {
	try {
		final spots = await database.queryAvailableSpots();
		res.json(spots);
	} catch (e) {
		res.status(500).json({'error': 'Databasfel: $e'});
	}
});`},!1),s("current",A,async()=>{t(a,!0),await y.update`// Klient (mobilapp)
Future<void> getAndDisplayAvailableSpots() async {

	final response = await http.get('https://parkering-api.se/spots/available');
	final List<dynamic> data = json.decode(response.body);
	final spots = data.map((json) => ParkingSpot.fromJson(json)).toList();
	displaySpots(spots);

}

// Server
app.get('/spots/available', (req, res) async {
	try {
		final spots = await database.queryAvailableSpots();
		res.json(spots);
	} catch (e) {
		res.status(500).json({'error': 'Databasfel: $e'});
	}
});

// Databasoperation (förenklas här)
Future<List<ParkingSpot>> queryAvailableSpots() async {
	// Simulerar databasanrop
	await Future.delayed(Duration(milliseconds: 100));
	return [
		ParkingSpot('A1', 'Norra Parkeringen', 25.0, true),
		ParkingSpot('B2', 'Södra Parkeringen', 20.0, false),
	];
}`},!1),s("current",T,async()=>{t(a,!1),await y.update``},!1),s("current",G,async()=>{t(a,!1),await y.update``},!1),s("current",V,async()=>{t(a,!0),await y.update`void main() {
	startServer(port: 8080);

	handleRequest('/parking/available', (request) {
		var availableSpots = database.getAvailableSpots();
		return Response.json(availableSpots);
	});

	handleRequest('/parking/start', (request) {
		var spotId = request.data['spotId'];
		var vehicleId = request.data['vehicleId'];
		database.startParking(spotId, vehicleId);
		return Response.ok('Parkering påbörjad');
	});
}`},!1),s("current",K,async()=>{t(a,!1),await y.update``},!1),s("current",we,async()=>{t(a,!0),await y.update`// Asynkron hantering av förfrågan
Future<void> handleParkingRequest(Request request) async {
	var spotId = request.data['spotId'];
	var vehicleId = request.data['vehicleId'];

	// Asynkron databasoperation
	await database.startParking(spotId, vehicleId);

	// Servern kan hantera andra förfrågningar medan den väntar
	return Response.ok('Parkering påbörjad');
}`},!1),l(N,m)},$$slots:{default:!0}}),l(p,o)},$$slots:{default:!0}}),l(u,r)},$$slots:{default:!0}});var ne=e(e(le,!0));w(ne,{children:(u,j)=>{var r=Be(),i=c(r);S(i,{title:"Grundläggande inspelning i OBS Studio"});var g=e(e(i,!0));P(g,{children:(p,x)=>{var o=Je();l(p,o)},$$slots:{default:!0}}),l(u,r)},$$slots:{default:!0}});var oe=e(e(ne,!0));w(oe,{children:(u,j)=>{var r=Me(),i=c(r);S(i,{title:"Git - Förberedelser"});var g=e(e(i,!0));P(g,{children:(p,x)=>{var o=Ce();l(p,o)},$$slots:{default:!0}}),l(u,r)},$$slots:{default:!0}});var de=e(e(oe,!0));w(de,{children:(u,j)=>{var r=He(),i=c(r);S(i,{title:"Git - Nytt projekt"});var g=e(e(i,!0));P(g,{children:(p,x)=>{var o=Oe();l(p,o)},$$slots:{default:!0}}),l(u,r)},$$slots:{default:!0}});var ce=e(e(de,!0));w(ce,{children:(u,j)=>{var r=We(),i=c(r);S(i,{title:"Git - Grundläggande Arbetsflöde"});var g=e(e(i,!0));P(g,{children:(p,x)=>{var o=Ue();l(p,o)},$$slots:{default:!0}}),l(u,r)},$$slots:{default:!0}});var ue=e(e(ce,!0));w(ue,{children:(u,j)=>{var r=Qe(),i=c(r);S(i,{title:"Tack för idag!"});var g=e(e(i,!0));P(g,{children:(p,x)=>{var o=ze();l(p,o)},$$slots:{default:!0}}),l(u,r)},$$slots:{default:!0}});var ge=e(e(ue,!0));w(ge,{children:(u,j)=>{var r=Ye(),i=c(r);S(i,{title:"Repository med Lokal Datalagring"});var g=e(e(i,!0));P(g,{children:(p,x)=>{var o=E(!0),I=c(o);U(I,{children:(N,W)=>{var m=Xe(),f=c(m),v=n(f),k=e(e(v,!0)),_=n(k),L=e(e(k,!0)),h=e(e(L,!0)),b=n(h),A=e(e(b,!0)),T=e(e(A,!0)),q=e(e(h,!0)),G=e(e(f,!0)),D=n(G),V=n(D);O(H(V,{code:"",theme:"catppuccin-frappe",lang:"dart",autoIndent:!0,options:{duration:600,stagger:15,containerStyle:!1,lineNumbers:!0},class:"overflow-y-clip"}),K=>R=K,()=>R),C(()=>D.hidden=!M(a)),s("current",v,async()=>{t(a,!1),await R.update``},!1),s("current",_,async()=>{t(a,!0),await R.update`// In-memory Repository
	abstract class Repository<T> {
		List<T> _items = [];
		
		void add(T item) => _items.add(item);
		List<T> getAll() => _items;
	}`},!1),s("current",L,async()=>{t(a,!1),await R.update``},!1),s("current",b,async()=>{t(a,!0),await R.update`abstract class FileRepository<T> {
		final String filePath;
		FileRepository(this.filePath);
	
		// Konvertering till/från JSON
		T fromJson(Map<String, dynamic> json);
		Map<String, dynamic> toJson(T item);
	}`},!1),s("current",A,async()=>{t(a,!0),await R.update`abstract class FileRepository<T> {
		final String filePath;
		FileRepository(this.filePath);
	
		// Konvertering till/från JSON
		T fromJson(Map<String, dynamic> json);
		Map<String, dynamic> toJson(T item);
	
		// Läser från fil
		Future<List<T>> readFile() async {
			final file = File(filePath);
			if (!await file.exists()) {
				await file.writeAsString('[]');
				return [];
			}
			final content = await file.readAsString();
			final List<dynamic> jsonList = jsonDecode(content);
			return jsonList.map((json) => fromJson(json)).toList();
		}
	}`},!1),s("current",T,async()=>{t(a,!0),await R.update`abstract class FileRepository<T> {
		final String filePath;
		FileRepository(this.filePath);
	
		T fromJson(Map<String, dynamic> json);
		Map<String, dynamic> toJson(T item);
	
		Future<List<T>> readFile() async {
			final file = File(filePath);
			if (!await file.exists()) {
				await file.writeAsString('[]');
				return [];
			}
			final content = await file.readAsString();
			final List<dynamic> jsonList = jsonDecode(content);
			return jsonList.map((json) => fromJson(json)).toList();
		}
	
		// Skriver till fil
		Future<void> writeFile(List<T> items) async {
			final file = File(filePath);
			final jsonList = items.map((item) => toJson(item)).toList();
			await file.writeAsString(jsonEncode(jsonList));
		}
	
		// Lägger till item
		Future<void> add(T item) async {
			final items = await readFile();
			items.add(item);
			await writeFile(items);
		}
	}`},!1),s("current",q,async()=>{t(a,!0),await R.update`// Användning
	class Person {
		final String id;
		final String name;
		Person(this.id, this.name);
	}
	
	class PersonRepository extends FileRepository<Person> {
		PersonRepository() : super('persons.json');
		
		@override
		Person fromJson(Map<String, dynamic> json) {
			return Person(json['id'], json['name']);
		}
		
		@override
		Map<String, dynamic> toJson(Person person) {
			return {'id': person.id, 'name': person.name};
		}
	}`},!1),l(N,m)},$$slots:{default:!0}}),l(p,o)},$$slots:{default:!0}}),l(u,r)},$$slots:{default:!0}});var ye=e(e(ge,!0)),_e=n(ye),be=n(_e);be.nodeValue=ve,l(he,Z)},$$slots:{default:!0}}),l(me,Y)}export{ca as component};
